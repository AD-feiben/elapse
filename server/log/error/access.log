[2018-02-08T21:57:47.836] [ERROR] error - 
    POST /article/new 400 
      req: {"title":"前端加载之首屏时间","desc":"本文将介绍前端计算首屏时间的方法。","cover":"","article":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_fe","tags":["首屏加载","前端"],"author":"zx","state":"draft","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键cover, 值不通过"}
  
[2018-02-08T22:23:03.385] [ERROR] error - 
    GET /article/5a7c57a7694afd0f94c21a3b 404 
      req: {} 
      res: 
  
[2018-02-08T23:26:27.613] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间4","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_fe","tags":["首屏加载","前端"],"author":"zx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading"} 
      res: {"errMsg":"article.replace is not a function"}
  
[2018-02-08T23:27:33.347] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间5","desc":"本文将介绍前端计算首屏时间的方法","cover":"http//p39p1kvxnbktclouddncom/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":" 首屏时间\n本文将介绍前端计算首屏时间的方法\n\n 计算原理与编码\n计算首屏时间主要用到事件DOMContentLoaded关于DOMContentLoaded和load的区别MDN的介绍是\n\n 当初始的 HTML 文档被完全加载和解析完成之后DOMContentLoaded 事件被触发而无需等待样式表图像和子框架的完成加载 load 应该仅用于检测一个完全加载的页面\n\n那么只要在DOMContentLoaded之前开始计时然后在DOMContentLoaded时计算结束时间即可得出首屏时间\n但是别忘了如果首屏有图片图片的加载也是需要时间的综上计算首屏的思路为\n\n判断首屏有没有图片如果没图片就用domready为结束时间如果有图判断加载状态加载完毕之后则首屏完成加载此时为结束时间\n\n那么问题来了开始时间怎么算一个简单暴力的方法在html的head开始计算即\n\n\nhead\n  script type\"text/javascript\"\n  windowloadStartTime  new Date\n  /script\n/head\n\n\n那么就可以在windowonload时计算首屏时间了代码如下\n\n\n// 当初始的 HTML 文档被完全加载和解析完成之后DOMContentLoaded 事件被触发而无需等待样式表图像和子框架的完成加载\ndomContentLoaded  \n  const totalHeight  windowpageYOffset  documentdocumentElementscrollTop // 页面总高度\n  const viewHeight  documentdocumentElementclientHeight                     // 页面可视高度\n\n  const imgs  ArrayfromdocumentquerySelectorAllimgmapimg         // 在首屏的图片\n    const offsetTop  imggetBoundingClientRecttop + viewHeight // 图片所在高度\n    return offsetTop  totalHeight ? img  null\n  \n\n  const imgsLoadedTime                                                      // 图片加载所需时间\n  let endTime  + new Date                                                     // 结束时间\n  if imgslength  0 \n    imgsforEachimg  \n      if img  imgcomplete \n        return\n      \n\n      const image  new Image\n      imagesrc  imgsrc\n      imageonload    imgsLoadedTimepush+ new Date\n      imageonerror    imgsLoadedTimepush+ new Date\n    \n   else \n    endTime  + new Date\n  \n\n  // load 应该仅用于检测一个完全加载的页面 \n  windowonload    \n    consolelogimgsLoadedTime\n    if imgsLoadedTimelength  0 \n      endTime  Mathmaxapplynull imgsLoadedTime\n    \n    const firstScreenTime  endTime - loadStartTime\n    consolelog首屏时间  firstScreenTime\n  \n\n\n其中domContentLoaded是我对DOMContentLoaded的封装为了兼容百度一下你就会写\n\n windowperformence\n说了这么多其实在不考虑兼容性的情况下可以直接用windowperformencetiming来计算首屏时间和白屏时间而且兼容性还不错\n其中\n  - 白屏时间  domLoading - fetchStart\n  - 首屏时间  domContentLoadedEventEnd - domLoading","classify":"web_fe","tags":["首屏加载","前端"],"author":"zx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading"} 
      res: {"errMsg":"article[key].replace is not a function"}
  
[2018-02-08T23:28:44.432] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间3","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_fe","tags":["首屏加载","前端"],"author":"zx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading"} 
      res: {"errMsg":"JOSN is not defined"}
  
[2018-02-08T23:29:00.532] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间2","desc":"本文将介绍前端计算首屏时间的方法","cover":"http//p39p1kvxnbktclouddncom/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":" 首屏时间\n本文将介绍前端计算首屏时间的方法\n\n 计算原理与编码\n计算首屏时间主要用到事件DOMContentLoaded关于DOMContentLoaded和load的区别MDN的介绍是\n\n 当初始的 HTML 文档被完全加载和解析完成之后DOMContentLoaded 事件被触发而无需等待样式表图像和子框架的完成加载 load 应该仅用于检测一个完全加载的页面\n\n那么只要在DOMContentLoaded之前开始计时然后在DOMContentLoaded时计算结束时间即可得出首屏时间\n但是别忘了如果首屏有图片图片的加载也是需要时间的综上计算首屏的思路为\n\n判断首屏有没有图片如果没图片就用domready为结束时间如果有图判断加载状态加载完毕之后则首屏完成加载此时为结束时间\n\n那么问题来了开始时间怎么算一个简单暴力的方法在html的head开始计算即\n\n\nhead\n  script type\"text/javascript\"\n  windowloadStartTime  new Date\n  /script\n/head\n\n\n那么就可以在windowonload时计算首屏时间了代码如下\n\n\n// 当初始的 HTML 文档被完全加载和解析完成之后DOMContentLoaded 事件被触发而无需等待样式表图像和子框架的完成加载\ndomContentLoaded  \n  const totalHeight  windowpageYOffset  documentdocumentElementscrollTop // 页面总高度\n  const viewHeight  documentdocumentElementclientHeight                     // 页面可视高度\n\n  const imgs  ArrayfromdocumentquerySelectorAllimgmapimg         // 在首屏的图片\n    const offsetTop  imggetBoundingClientRecttop + viewHeight // 图片所在高度\n    return offsetTop  totalHeight ? img  null\n  \n\n  const imgsLoadedTime                                                      // 图片加载所需时间\n  let endTime  + new Date                                                     // 结束时间\n  if imgslength  0 \n    imgsforEachimg  \n      if img  imgcomplete \n        return\n      \n\n      const image  new Image\n      imagesrc  imgsrc\n      imageonload    imgsLoadedTimepush+ new Date\n      imageonerror    imgsLoadedTimepush+ new Date\n    \n   else \n    endTime  + new Date\n  \n\n  // load 应该仅用于检测一个完全加载的页面 \n  windowonload    \n    consolelogimgsLoadedTime\n    if imgsLoadedTimelength  0 \n      endTime  Mathmaxapplynull imgsLoadedTime\n    \n    const firstScreenTime  endTime - loadStartTime\n    consolelog首屏时间  firstScreenTime\n  \n\n\n其中domContentLoaded是我对DOMContentLoaded的封装为了兼容百度一下你就会写\n\n windowperformence\n说了这么多其实在不考虑兼容性的情况下可以直接用windowperformencetiming来计算首屏时间和白屏时间而且兼容性还不错\n其中\n  - 白屏时间  domLoading - fetchStart\n  - 首屏时间  domContentLoadedEventEnd - domLoading","classify":"web_fe","tags":["首屏加载","前端"],"author":"zx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading"} 
      res: {"errMsg":"Unexpected string in JSON at position 6"}
  
[2018-02-08T23:33:16.505] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间3","desc":"本文将介绍前端计算首屏时间的方法","cover":"http//p39p1kvxnbktclouddncom/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":" 首屏时间\n本文将介绍前端计算首屏时间的方法\n\n 计算原理与编码\n计算首屏时间主要用到事件DOMContentLoaded关于DOMContentLoaded和load的区别MDN的介绍是\n\n 当初始的 HTML 文档被完全加载和解析完成之后DOMContentLoaded 事件被触发而无需等待样式表图像和子框架的完成加载 load 应该仅用于检测一个完全加载的页面\n\n那么只要在DOMContentLoaded之前开始计时然后在DOMContentLoaded时计算结束时间即可得出首屏时间\n但是别忘了如果首屏有图片图片的加载也是需要时间的综上计算首屏的思路为\n\n判断首屏有没有图片如果没图片就用domready为结束时间如果有图判断加载状态加载完毕之后则首屏完成加载此时为结束时间\n\n那么问题来了开始时间怎么算一个简单暴力的方法在html的head开始计算即\n\n\nhead\n  script type\"text/javascript\"\n  windowloadStartTime  new Date\n  /script\n/head\n\n\n那么就可以在windowonload时计算首屏时间了代码如下\n\n\n// 当初始的 HTML 文档被完全加载和解析完成之后DOMContentLoaded 事件被触发而无需等待样式表图像和子框架的完成加载\ndomContentLoaded  \n  const totalHeight  windowpageYOffset  documentdocumentElementscrollTop // 页面总高度\n  const viewHeight  documentdocumentElementclientHeight                     // 页面可视高度\n\n  const imgs  ArrayfromdocumentquerySelectorAllimgmapimg         // 在首屏的图片\n    const offsetTop  imggetBoundingClientRecttop + viewHeight // 图片所在高度\n    return offsetTop  totalHeight ? img  null\n  \n\n  const imgsLoadedTime                                                      // 图片加载所需时间\n  let endTime  + new Date                                                     // 结束时间\n  if imgslength  0 \n    imgsforEachimg  \n      if img  imgcomplete \n        return\n      \n\n      const image  new Image\n      imagesrc  imgsrc\n      imageonload    imgsLoadedTimepush+ new Date\n      imageonerror    imgsLoadedTimepush+ new Date\n    \n   else \n    endTime  + new Date\n  \n\n  // load 应该仅用于检测一个完全加载的页面 \n  windowonload    \n    consolelogimgsLoadedTime\n    if imgsLoadedTimelength  0 \n      endTime  Mathmaxapplynull imgsLoadedTime\n    \n    const firstScreenTime  endTime - loadStartTime\n    consolelog首屏时间  firstScreenTime\n  \n\n\n其中domContentLoaded是我对DOMContentLoaded的封装为了兼容百度一下你就会写\n\n windowperformence\n说了这么多其实在不考虑兼容性的情况下可以直接用windowperformencetiming来计算首屏时间和白屏时间而且兼容性还不错\n其中\n  - 白屏时间  domLoading - fetchStart\n  - 首屏时间  domContentLoadedEventEnd - domLoading","classify":"web_fe","tags":["首屏加载","前端"],"author":"zx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"article[key].replace is not a function"}
  
[2018-02-08T23:39:48.646] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"Internal Server Error"}
  
[2018-02-08T23:40:03.698] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"Internal Server Error"}
  
[2018-02-08T23:40:50.158] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"Internal Server Error"}
  
[2018-02-08T23:42:00.430] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"Internal Server Error"}
  
[2018-02-08T23:43:14.860] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:44:44.974] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:45:14.526] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:45:26.444] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:45:45.233] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:46:08.042] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:46:27.785] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:47:03.615] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:47:22.137] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:48:39.830] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:48:46.252] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:49:29.472] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-08T23:51:47.854] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"Internal Server Error"}
  
[2018-02-08T23:53:17.972] [FATAL] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 500 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: 
  
[2018-02-08T23:53:26.537] [ERROR] error - 
    PATCH /article/5a7c62ad64d6df15279dabbf 400 
      req: {"title":"前端加载之首屏时间3245324","desc":"本文将介绍前端计算首屏时间的方法。","cover":"http://p39p1kvxn.bkt.clouddn.com/FjL-oLC0Ca_HCeY5DSN4EjN_agRi","content":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","classify":"web_be","tags":["首屏加载","前端"],"author":"zzx","state":"publish","content_md":"# 首屏时间\n本文将介绍前端计算首屏时间的方法。\n\n## 计算原理与编码\n计算首屏时间主要用到事件`DOMContentLoaded`，关于`DOMContentLoaded`和`load`的区别，MDN的介绍是：\n\n> 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。\n\n那么只要在`DOMContentLoaded`之前开始计时，然后在`DOMContentLoaded`时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：\n\n*判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。*\n\n那么问题来了，`开始时间怎么算？`,一个简单暴力的方法，在`html`的`head`开始计算，即：\n\n```\n<head>\n  <script type=\"text/javascript\">\n  window.loadStartTime = new Date()\n  </script>\n</head>\n```\n\n那么就可以在`window.onload`时计算首屏时间了，代码如下：\n\n```\n// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() => {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img => {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop < totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length > 0) {\n    imgs.forEach(img => {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () => imgsLoadedTime.push(+ new Date)\n      image.onerror = () => imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () => {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length > 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n```\n其中,`domContentLoaded`是我对`DOMContentLoaded`的封装（为了兼容，百度一下，你就会写）。\n\n## window.performence\n说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：\n  - 白屏时间 = domLoading - fetchStart\n  - 首屏时间 = domContentLoadedEventEnd - domLoading","content_html":"<h1 id=\"\">首屏时间</h1>\n<p>本文将介绍前端计算首屏时间的方法。</p>\n<h2 id=\"-1\">计算原理与编码</h2>\n<p>计算首屏时间主要用到事件<code>DOMContentLoaded</code>，关于<code>DOMContentLoaded</code>和<code>load</code>的区别，MDN的介绍是：</p>\n<blockquote>\n  <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载; load 应该仅用于检测一个完全加载的页面。</p>\n</blockquote>\n<p>那么只要在<code>DOMContentLoaded</code>之前开始计时，然后在<code>DOMContentLoaded</code>时计算结束时间即可得出首屏时间。\n但是，别忘了如果首屏有图片，图片的加载也是需要时间的。综上，计算首屏的思路为：</p>\n<p><em>判断首屏有没有图片，如果没图片就用domready为结束时间。如果有图，判断加载状态，加载完毕之后则首屏完成加载，此时为结束时间。</em></p>\n<p>那么问题来了，<code>开始时间怎么算？</code>,一个简单暴力的方法，在<code>html</code>的<code>head</code>开始计算，即：</p>\n<pre><code>&lt;head&gt;\n  &lt;script type=\"text/javascript\"&gt;\n  window.loadStartTime = new Date()\n  &lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>那么就可以在<code>window.onload</code>时计算首屏时间了，代码如下：</p>\n<pre><code>// 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。\ndomContentLoaded(() =&gt; {\n  const totalHeight = window.pageYOffset || document.documentElement.scrollTop // 页面总高度\n  const viewHeight = document.documentElement.clientHeight                     // 页面可视高度\n\n  const imgs = Array.from(document.querySelectorAll('img')).map(img =&gt; {       // 在首屏的图片\n    const offsetTop = img.getBoundingClientRect().top + viewHeight // 图片所在高度\n    return offsetTop &lt; totalHeight ? img : null\n  })\n\n  const imgsLoadedTime = []                                                    // 图片加载所需时间\n  let endTime = + new Date                                                     // 结束时间\n  if (imgs.length &gt; 0) {\n    imgs.forEach(img =&gt; {\n      if (!img || img.complete) {\n        return\n      }\n\n      const image = new Image()\n      image.src = img.src\n      image.onload = () =&gt; imgsLoadedTime.push(+ new Date)\n      image.onerror = () =&gt; imgsLoadedTime.push(+ new Date)\n    })\n  } else {\n    endTime = + new Date\n  }\n\n  // load 应该仅用于检测一个完全加载的页面。 \n  window.onload = () =&gt; {\n    console.log(imgsLoadedTime)\n    if (imgsLoadedTime.length &gt; 0) {\n      endTime = Math.max.apply(null, imgsLoadedTime)\n    }\n    const firstScreenTime = endTime - loadStartTime\n    console.log('首屏时间: ', firstScreenTime)\n  }\n})\n</code></pre>\n<p>其中,<code>domContentLoaded</code>是我对<code>DOMContentLoaded</code>的封装（为了兼容，百度一下，你就会写）。</p>\n<h2 id=\"windowperformence\">window.performence</h2>\n<p>说了这么多，其实在不考虑兼容性的情况下，可以直接用window.performence.timing来计算首屏时间和白屏时间（而且兼容性还不错），\n其中：</p>\n<ul>\n<li>白屏时间 = domLoading - fetchStart</li>\n<li>首屏时间 = domContentLoadedEventEnd - domLoading</li>\n</ul>"} 
      res: {"errMsg":"键key, req[key]值不通过"}
  
[2018-02-09T16:30:20.145] [ERROR] error - 
    POST /user/login 400 
      req: {"account":"mvpzx","password":"KBen2015"} 
      res: {"errMsg":"账号或密码错误"}
  
